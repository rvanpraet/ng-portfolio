declare namespace gsap {

  type ChangeFunc = (self: FlipInstance) => any;
  type EnterOrLeaveCallback = (elements: Element[], makeAbsolute: Function) => any;

  interface FlipVars {
    targets?: Element | string | null | ArrayLike<Element | string>;
    change: ChangeFunc;
    scale?: boolean;
    onEnter?: EnterOrLeaveCallback;
    onLeave?: EnterOrLeaveCallback;
    wait?: boolean;
    absolute?: boolean;
    nested?: boolean;
    props?: string;
    swap?: "fade" | boolean;
    context?: Element | string;
    onInit?: Function;
    custom?: object;

    callbackScope?: object;
    onComplete?: Callback;
    onRepeat?: Callback;
    onRepeatParams?: any[];
    onReverseComplete?: Callback;
    onStart?: Callback;
    onUpdate?: Callback;
    delay?: TweenValue;
    duration?: TweenValue;
    ease?: string | EaseFunction;
    overwrite?: "auto" | boolean;
    stagger?: NumberValue | StaggerVars;
    snap?: object | number;
    [key: string]: any;
  }

  interface FitVars {
    scale?: boolean;
    absolute?: boolean;

    [key: string]: any;
  }

  interface FitReturnVars {
    x: number;
    y: number;
    width?: number;
    height?: number;
    scaleX?: number;
    scaleY?: number;

    [key: string]: any;
  }

  interface FlipInstance {
    readonly measured: boolean;
    readonly vars: FlipVars;
    readonly animation: core.Timeline;
    readonly targets: Element[];

    /**
     * Measures the final positions/dimensions and calculates the changes from the initial state (called automatically after change() unless wait: true is in the vars object)
     *
     * ```js
     * gsap.flip({
     *    wait: true,
     *    change(self) {
     *        element.addEventListener("load", () => self.measure().play());
     *    }
     * });
     * ```
     *
     * @returns {core.Timeline} The resulting Timeline animation
     * @memberof Flip
     */
    measure(): core.Timeline;

    /**
     * After the measure() has occurred, gets the "from" value for the given property of the target like "x", "y", "width", etc.
     *
     * ```js
     * flipInstance.getFrom(element, "x");
     * ```
     *
     * @param {Element | string} target
     * @param {string} property
     * @returns {number | string} the "from" value
     * @memberof Flip
     */
    getFrom(target: Element | string, property: string): number | string;
  }

  interface FlipStatic {
    register(core: typeof gsap): void;

    /**
     * Calculates the x/y transforms (and width/height or scaleX/scaleY) to fit one element exactly into the bounding box of another element.
     *
     * ```js
     * let vars = Flip.fit(".el-1", ".el-2", {scale: true, absolute: true, ease: "power2"});
     * ```
     *
     * @param {Element | string} fromElement
     * @param {Element | string} toElement
     * @param {FitVars} vars
     * @returns {object} An object containing "x" and "y" properties along with either "width" and "height" (default), or if scale: true is in the vars object, "scaleX" and "scaleY" properties. It will also include any standard tween-related properties ("scale" and "absolute" will be stripped out)
     * @memberof Flip
     */
    fit(fromElement: Element | string, toElement: Element | string, vars?: FitVars): FitReturnVars;
  }

  interface Flip extends FlipStatic {
    new(): FlipInstance;
    prototype: FlipInstance;
  }

  /**
   * Smoothly transitions elements to the new positions/sizes set in the change() function.
   *
   * @param {FlipVars} vars
   * @returns {FlipInstance} Flip object
   * @memberof gsap
   */
  function flip(vars: FlipVars): FlipInstance;
}

declare const Flip: gsap.Flip;

declare module "gsap/Flip" {
  export const Flip: gsap.Flip;
  export { Flip as default };
}

declare module "gsap/dist/Flip" {
  export * from "gsap/Flip";
  export { Flip as default } from "gsap/Flip";
}

declare module "gsap/src/Flip" {
  export * from "gsap/Flip";
  export { Flip as default } from "gsap/Flip";
}

declare module "gsap/all" {
  export * from "gsap/Flip";
}