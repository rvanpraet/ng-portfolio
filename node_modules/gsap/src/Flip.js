/*!
 * EasePack 3.6.0
 * https://greensock.com
 *
 * @license Copyright 2008-2020, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/* eslint-disable */

export const Flip = {
	name: "flip",
	register(gsap) {
		let _id = 1,
			_toArray = gsap.utils.toArray,
			_find = context => _toArray(_toArray(context || document.body)[0].querySelectorAll("[data-flip-id]")),
			_reserved = {change:1, targets:1, onComplete:1, onUpdate:1, onStart:1, delay:1, scale:1, context:1, swap:1, wait:1, onInit:1, absolute:1, props:1, onEnter:1, onLeave:1},
			_makeAbsolute = (elements, state, result) => {
				for (let i = 0; i < elements.length; i++) {
					let el = elements[i],
						s = state[i], b, o;
					el.parentNode || (s.p && s.p.appendChild(el))
					gsap.getProperty(el, "display") === "none" && (el.style.display = s.d);
					el.style.position = "absolute";
					el.style.width = s.w + "px";
					el.style.height = s.h + "px";
					el.style.top = el.style.left = "0px";
					b = el.getBoundingClientRect();
					o = {x: s.l - b.left, y: s.t - b.top};
					gsap.set(el, {x: "+=" + o.x, y: "+=" + o.y });
					result && (result[i] = o);
				}
				return result;
			},
			_getDimensions = el => {
				let b = el.getBoundingClientRect(),
					getProp = gsap.getProperty(el);
				return { el: el, d: getProp("display"), p: el.parentNode, sx: getProp("scaleX"), sy: getProp("scaleY"), x: getProp("x"), y: getProp("y"), l: b.left, t: b.top, w: parseFloat(getProp("width", "px")), h: parseFloat(getProp("height", "px")), bw: b.width, bh: b.height, css: el.style.cssText, o: getProp("opacity"), origin: getComputedStyle(el).transformOrigin.split(" ").map(parseFloat) };
			},
			_pluckTransitioning = (elements, transitioning, before, after, callback, tl, useBefore) => {
				if (transitioning.length) {
					let state = useBefore ? before : after,
						recordedStates = [],
						i, index, el;
					for (i = 0; i < transitioning.length; i++) {
						el = transitioning[i];
						index = elements.indexOf(el);
						useBefore || (before[index].d === "none" && (el.style.display = after[index].d));
						if (~index) {
							recordedStates.push(state[index]);
							elements.splice(index, 1);
							before.splice(index, 1);
							after.splice(index, 1);
						} else {
							recordedStates.push(_getDimensions(transitioning[i]));
						}
					}
					callback && tl.add(callback(transitioning, () => _makeAbsolute(transitioning, recordedStates) || transitioning), 0);
				}
			};
		gsap.flip = vars => {
			(typeof(vars) !== "object" || vars.push) && (vars = {targets: vars});
			let {onComplete, delay, scale, targets, change, onUpdate, onStart, context, swap, onInit, absolute, props, onEnter, onLeave} = vars,
				elements = targets ? _toArray(targets) : _find(context),
				tl = gsap.timeline({delay, onStart, onUpdate, onComplete}),
				fade = swap === "fade" && [],
				lookup = {},
				before = elements.map(_getDimensions),
				copy = {},
				entering = [],
				p, onReady, changeResult;
			props && (props = props.split(" ").join("").split(","));
			elements.forEach((el, i) => {
				let id = el.getAttribute("data-flip-id");
				id || el.setAttribute("data-flip-id", (id = "" + _id++));
				lookup[id] = before[i];
				fade && (fade[i] = before[i].o);
				(before[i].d === "none" || !before[i].p) && entering.push(el);
				if (props) {
					let getProp = gsap.getProperty(el, null, "native"),
						obj = before[i].props = {};
					i = props.length;
					while (i--) {
						obj[props[i]] = getProp(props[i]);
					}
				}
				el._flip && el._flip.progress(1);
				el._flip = tl;
			});
			onReady = () => {
				let swapIn = [],
					swapOut = [],
					remove = () => swapOut.forEach(el => el.parentNode && el.parentNode.removeChild(el)),
					offsets = absolute && [],
					after, index, id, el, state, all, i, x, y, width, height, scaleX, scaleY, leaving;
				all = _find(context);
				for (i = 0; i < all.length; i++) {
					el = all[i];
					id = el.getAttribute("data-flip-id");
					state = lookup[id];
					if (!state) {
						entering.push(el);
					} else if (swap !== false && state.el !== el) { // swap!
						elements.push(el);
						before.push(state);
						swapIn.push(el);
						swapOut.push(state.el);
						el._flip = tl;
						if (fade) {
							fade.push(0);
							state.el.style.opacity = "0";
						}
					}
				}
				swapOut.length || (fade = false);
				after = elements.map(_getDimensions);
				for (p in vars) {
					_reserved[p] || (copy[p] = vars[p]);
				}
				props && props.forEach(p => copy[p] = i => before[i].props[p]);
				_pluckTransitioning(elements, entering, before, after, onEnter, tl);
				if (onLeave) {
					leaving = [];
					i = elements.length;
					while (i--) {
						(after[i].d === "none" || !after[i].p) && leaving.push(elements[i]);
					}
					_pluckTransitioning(elements, leaving, before, after, onLeave, tl, true);
				}
				if (scale) {
					copy.x = x = i => after[i].x + (before[i].l - after[i].l) + ((before[i].bw / after[i].bw) * after[i].sx - after[i].sx) * after[i].origin[0];
					copy.y = y = i => after[i].y + (before[i].t - after[i].t) + ((before[i].bh / after[i].bh) * after[i].sy - after[i].sy) * after[i].origin[1];
					copy.scaleX = scaleX = i => after[i].sx * (before[i].bw / after[i].bw);
					copy.scaleY = scaleY = i => after[i].sy * (before[i].bh / after[i].bh);
				} else {
					absolute && (offsets = _makeAbsolute(elements, after, []));
					copy.x = x = i => after[i].x + (before[i].l - after[i].l) + (absolute ? offsets[i].x : 0);
					copy.y = y = i => after[i].y + (before[i].t - after[i].t) + (absolute ? offsets[i].y : 0);
					copy.width = width = i => before[i].w;
					copy.height = height = i => before[i].h;
				}
				fade ? (copy.opacity = i => fade[i]) : remove();
				copy.onComplete = () => elements.forEach((el, i) => {el._gsap.uncache = 1; el.style.cssText = after[i].css;}) || !fade || remove();
				swapOut.forEach((el, i) => {
					index = elements.indexOf(el);
					after[index] = before[index];
					before[index] = after[elements.indexOf(swapIn[i])];
					let v = {x: x(index), y: y(index)};
					if (scale) {
						v.scaleX = scaleX(index);
						v.scaleY = scaleY(index);
					} else {
						v.width = width(index);
						v.height = height(index);
					}
					gsap.set(el, v);
					before[index] = after[index];
				});
				onInit && onInit(tl, before, after);
				return (elements.length ? tl.from(elements, copy, 0) : tl).play();
			};
			changeResult = change(onReady);
			changeResult && changeResult instanceof gsap.core.Animation && tl.add(changeResult, 0);
			return vars.wait ? tl.pause() : onReady();
		}

		// add flip() to timelines? Potential future feature
		// gsap.core.Timeline.prototype.flip = function(vars, position) {
		// 	let temp = gsap.to({}, {duration: vars.duration, delay: vars.delay, onStart: () => {
		// 			temp.parent.add(gsap.flip(vars), temp._start - temp._delay);
		// 			temp.kill();
		// 		}
		// 	});
		// 	return this.add(temp, position);
		// };

	}
};

typeof(window) !== "undefined" && window.gsap && window.gsap.registerPlugin(Flip);

export { Flip as default };