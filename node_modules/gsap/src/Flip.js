/*!
 * EasePack 3.6.0
 * https://greensock.com
 *
 * @license Copyright 2008-2020, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
/* eslint-disable */

let _id = 1,
	_toArray, gsap, _calcGrowthDirection,
	_find = context => _toArray(_toArray(context || document.body)[0].querySelectorAll("[data-flip-id]")),
	_reserved = {change:1, targets:1, onComplete:1, onUpdate:1, onStart:1, delay:1, scale:1, context:1, swap:1, wait:1, onInit:1, absolute:1, props:1, onEnter:1, onLeave:1, custom:1, paused:1, nested:1},
	_copy = obj => {
		let result = {}, p;
		for (p in obj) {
			_reserved[p] || (result[p] = obj[p]);
		}
		return result;
	},
	_makeAbsolute = (elements, state, result) => {
		for (let i = 0; i < elements.length; i++) {
			let el = elements[i],
				s = state[i], b, o,
				style = el.style;
			el.parentNode || (s.p && s.p.appendChild(el))
			gsap.getProperty(el, "display") === "none" && (style.display = s.d);
			style.position = "absolute";
			style.width = s.w + "px";
			style.height = s.h + "px";
			style.top || (style.top = "0px");
			style.left || (style.left = "0px");
			b = el.getBoundingClientRect();
			o = {x: s.l - b.left, y: s.t - b.top};
			gsap.set(el, {x: "+=" + o.x, y: "+=" + o.y });
			result && (result[i] = o);
		}
		return result;
	},
	_getDimensions = el => {
		let b = el.getBoundingClientRect(),
			getProp = gsap.getProperty(el);
		return { el: el, d: getProp("display"), p: el.parentNode, sx: getProp("scaleX"), sy: getProp("scaleY"), x: getProp("x"), y: getProp("y"), l: b.left, t: b.top, w: parseFloat(getProp("width", "px")), h: parseFloat(getProp("height", "px")), bw: b.width, bh: b.height, css: el.style.cssText, o: getProp("opacity"), rx:0, ry:0, origin: getComputedStyle(el).transformOrigin.split(" ").map(parseFloat) };
	},
	_populateGrowthRatios = measurements => {
		let {w, h, el, l, t, bw, bh} = measurements,
			style = el.style,
			startWidth = style.width,
			startHeight = style.height,
			b2;
		style.width = (w + 100) + "px";
		style.height = (h + 100) + "px";
		b2 = el.getBoundingClientRect();
		measurements.rx = Math.abs((b2.left - l) / (b2.width - bw));
		measurements.ry = Math.abs((b2.top - t) / (b2.height - bh));
		startWidth ? (style.width = startWidth) : style.removeProperty("width");
		startHeight ? (style.height = startHeight) : style.removeProperty("height");
	},
	_getNestedOffsets = (el, property, flipTimeline) => {
		let value = 0,
			lookup = flipTimeline._flipProps;
		while (el) {
			if (el._flip === flipTimeline) {
				value += lookup[property](el._flipI) - gsap.getProperty(el, property);
			}
			el = el.parentNode;
		}
		return value;
	},
	_getX = (b, a, scale, offset, nested) => a.x + (b.l - a.l) + (scale ? ((b.bw / a.bw) * a.sx - a.sx) * a.origin[0] : (b.bw - a.bw) * a.rx) + offset - (nested ? _getNestedOffsets(a.p, "x", nested) : 0),
	_getY = (b, a, scale, offset, nested) => a.y + (b.t - a.t) + (scale ? ((b.bh / a.bh) * a.sy - a.sy) * a.origin[1] : (b.bh - a.bh) * a.ry) + offset - (nested ? _getNestedOffsets(a.p, "y", nested) : 0),
	_getScaleX = (b, a) => a.sx * (b.bw / a.bw),
	_getScaleY = (b, a) => a.sy * (b.bh / a.bh),
	// takes an Array of elements that are either transitioning out or in (onEnter/onLeave), removes them from the "elements" Array (and corresponding before/after), finds any that were set to display: none and sets them to what they are in the after state, and triggers a callback (if one is provided), passing the transitioning Array as well as a special function that the user can optionally call to make those elements position: absolute while keeping their viewport positions.
	_pluckTransitioning = (elements, transitioning, before, after, callback, tl, useBefore) => {
		if (transitioning.length) {
			let state = useBefore ? before : after,
				recordedStates = [],
				i, index, el;
			for (i = 0; i < transitioning.length; i++) {
				el = transitioning[i];
				index = elements.indexOf(el);
				useBefore || (before[index].d === "none" && (el.style.display = after[index].d));
				if (~index) {
					recordedStates.push(state[index]);
					elements.splice(index, 1);
					before.splice(index, 1);
					after.splice(index, 1);
				} else {
					recordedStates.push(_getDimensions(transitioning[i]));
				}
			}
			callback && tl.add(callback(transitioning, () => _makeAbsolute(transitioning, recordedStates) || transitioning), 0);
		}
	};

export class Flip {
	constructor(vars) {
		let {onComplete, delay, scale, targets, change, onUpdate, onStart, context, swap, onInit, absolute, props, onEnter, onLeave, custom, paused, wait, nested} = vars,
			self = this,
			elements = self.targets = targets ? _toArray(targets) : _find(context),
			tl = self.animation = gsap.timeline({delay, onStart, onUpdate, paused}),
			fade = swap === "fade" && [],
			lookup = {},
			copy = {},
			entering = [],
			p, changeResult, before;
		_calcGrowthDirection = 0;
		before = elements.map(_getDimensions)
		props && (props = props.split(" ").join("").split(","));
		self.measured = false;
		self.vars = vars;
		wait && tl.pause();
		elements.forEach((el, i) => {
			let id = el.getAttribute("data-flip-id");
			id || el.setAttribute("data-flip-id", (id = "" + _id++));
			lookup[id] = before[i];
			fade && (fade[i] = before[i].o);
			(before[i].d === "none" || !before[i].p) && entering.push(el);
			if (props) {
				let getProp = gsap.getProperty(el, null, "native"),
					obj = before[i].props = {};
				i = props.length;
				while (i--) {
					obj[props[i]] = getProp(props[i]);
				}
			}
			el._flip && el._flip.progress(1);
			el._flip = tl;
		});

		self.getFrom = (target, property) => typeof(copy[property]) === "function" && copy[property](elements.indexOf(_toArray(target)[0]));

		self.measure = () => {
			self.measured = true;
			let swapIn = [],
				swapOut = [],
				remove = () => swapOut.forEach(el => el.parentNode && el.parentNode.removeChild(el)),
				offsets = absolute && [],
				remainingProps = copy,
				after, index, id, el, state, all, i, x, y, width, height, scaleX, scaleY, leaving, v;
			if (context || swap) {
				all = _find(context);
				for (i = 0; i < all.length; i++) {
					el = all[i];
					id = el.getAttribute("data-flip-id");
					state = lookup[id];
					if (!state) {
						entering.push(el);
					} else if (swap !== false && state.el !== el) { // swap!
						elements.push(el);
						before.push(state);
						swapIn.push(el);
						swapOut.push(state.el);
						el._flip = tl;
						if (fade) {
							fade.push(0);
							state.el.style.opacity = "0";
						}
					}
				}
			}
			swapOut.length || (fade = false);
			after = elements.map(_getDimensions);
			for (p in vars) {
				_reserved[p] || (copy[p] = vars[p]);
			}
			props && props.forEach(p => copy[p] = i => before[i].props[p]);
			_pluckTransitioning(elements, entering, before, after, onEnter, tl);
			if (onLeave) {
				leaving = [];
				i = elements.length;
				while (i--) {
					(after[i].d === "none" || !after[i].p) && leaving.push(elements[i]);
				}
				_pluckTransitioning(elements, leaving, before, after, onLeave, tl, true);
			}
			if (scale) {
				copy.scaleX = scaleX = i => _getScaleX(before[i], after[i]);
				copy.scaleY = scaleY = i => _getScaleY(before[i], after[i]);
			} else {
				absolute && (offsets = _makeAbsolute(elements, after, []));
				scale || after.forEach(_populateGrowthRatios);
				copy.width = width = i => before[i].w;
				copy.height = height = i => before[i].h;
			}
			copy.x = x = i => _getX(before[i], after[i], scale, absolute ? offsets[i].x : 0, nested && tl);
			copy.y = y = i => _getY(before[i], after[i], scale, absolute ? offsets[i].y : 0, nested && tl);
			if (nested) {
				tl._flipProps = copy;
				elements.forEach((el, i) => el._flipI = i);
			}
			fade ? (copy.opacity = i => fade[i]) : remove();
			tl.eventCallback("onComplete", () => {
				elements.forEach((el, i) => {el._gsap.uncache = 1; el.style.cssText = after[i].css;}) || !fade || remove();
				onComplete && onComplete.apply(tl, vars.onCompleteParams || []);
			});
			swapOut.forEach((el, i) => {
				index = elements.indexOf(el);
				after[index] = before[index];
				before[index] = after[elements.indexOf(swapIn[i])];
				let v = {x: x(index), y: y(index)};
				if (scale) {
					v.scaleX = scaleX(index);
					v.scaleY = scaleY(index);
				} else {
					v.width = width(index);
					v.height = height(index);
				}
				gsap.set(el, v);
				before[index] = after[index];
			});
			onInit && onInit(self);
			if (custom && elements.length) { // bust out the custom properties as their own tweens so they can use different eases, durations, etc.
				remainingProps = _copy(copy);
				for (p in custom) {
					v = _copy(custom[p]);
					v[p] = copy[p];
					tl.from(elements, v, 0);
					delete remainingProps[p];
				}
			}
			return elements.length ? tl.from(elements, remainingProps, 0) : tl;
		};
		changeResult = change(self);
		changeResult && changeResult instanceof gsap.core.Animation && tl.add(changeResult, 0);
		wait || self.measured || self.measure();
	}

	static fit(fromEl, toEl, vars) {
		fromEl = _toArray(fromEl)[0];
		let v = vars ? _copy(vars) : {},
			before = _getDimensions(_toArray(toEl)[0]),
			after = _getDimensions(fromEl),
			{absolute, scale} = vars || v,
			offsets = absolute && _makeAbsolute([fromEl], [after], [])[0];
		v.x = _getX(before, after, scale, offsets ? offsets.x : 0);
		v.y = _getY(before, after, scale, offsets ? offsets.y : 0);
		if (scale) {
			v.scaleX = _getScaleX(before, after);
			v.scaleY = _getScaleY(before, after);
		} else {
			v.width = before.w;
			v.height = before.h;
		}
		return v;
	}

	static register(core) {
		gsap = core;
		_toArray = gsap.utils.toArray;
		gsap.flip = vars => new Flip(vars);
	}
}

// export const Flip = {
// 	name: "flip",
// 	register(gsap) {
// 		let _id = 1,
// 			_toArray = gsap.utils.toArray,
// 			_find = context => _toArray(_toArray(context || document.body)[0].querySelectorAll("[data-flip-id]")),
// 			_reserved = {change:1, targets:1, onComplete:1, onUpdate:1, onStart:1, delay:1, scale:1, context:1, swap:1, wait:1, onInit:1, absolute:1, props:1, onEnter:1, onLeave:1},
// 			_makeAbsolute = (elements, state, result) => {
// 				for (let i = 0; i < elements.length; i++) {
// 					let el = elements[i],
// 						s = state[i], b, o,
// 						style = el.style;
// 					el.parentNode || (s.p && s.p.appendChild(el))
// 					gsap.getProperty(el, "display") === "none" && (style.display = s.d);
// 					style.position = "absolute";
// 					style.width = s.w + "px";
// 					style.height = s.h + "px";
// 					style.top || (style.top = "0px");
// 					style.left || (style.left = "0px");
// 					b = el.getBoundingClientRect();
// 					o = {x: s.l - b.left, y: s.t - b.top};
// 					gsap.set(el, {x: "+=" + o.x, y: "+=" + o.y });
// 					result && (result[i] = o);
// 				}
// 				return result;
// 			},
// 			_getDimensions = el => {
// 				let b = el.getBoundingClientRect(),
// 					getProp = gsap.getProperty(el);
// 				return { el: el, d: getProp("display"), p: el.parentNode, sx: getProp("scaleX"), sy: getProp("scaleY"), x: getProp("x"), y: getProp("y"), l: b.left, t: b.top, w: parseFloat(getProp("width", "px")), h: parseFloat(getProp("height", "px")), bw: b.width, bh: b.height, css: el.style.cssText, o: getProp("opacity"), origin: getComputedStyle(el).transformOrigin.split(" ").map(parseFloat) };
// 			},
// 			_pluckTransitioning = (elements, transitioning, before, after, callback, tl, useBefore) => {
// 				if (transitioning.length) {
// 					let state = useBefore ? before : after,
// 						recordedStates = [],
// 						i, index, el;
// 					for (i = 0; i < transitioning.length; i++) {
// 						el = transitioning[i];
// 						index = elements.indexOf(el);
// 						useBefore || (before[index].d === "none" && (el.style.display = after[index].d));
// 						if (~index) {
// 							recordedStates.push(state[index]);
// 							elements.splice(index, 1);
// 							before.splice(index, 1);
// 							after.splice(index, 1);
// 						} else {
// 							recordedStates.push(_getDimensions(transitioning[i]));
// 						}
// 					}
// 					callback && tl.add(callback(transitioning, () => _makeAbsolute(transitioning, recordedStates) || transitioning), 0);
// 				}
// 			};
// 		gsap.flip = vars => {
// 			(typeof(vars) !== "object" || vars.push) && (vars = {targets: vars});
// 			let {onComplete, delay, scale, targets, change, onUpdate, onStart, context, swap, onInit, absolute, props, onEnter, onLeave} = vars,
// 				elements = targets ? _toArray(targets) : _find(context),
// 				tl = gsap.timeline({delay, onStart, onUpdate, onComplete}),
// 				fade = swap === "fade" && [],
// 				lookup = {},
// 				before = elements.map(_getDimensions),
// 				copy = {},
// 				entering = [],
// 				p, onReady, changeResult;
// 			props && (props = props.split(" ").join("").split(","));
// 			elements.forEach((el, i) => {
// 				let id = el.getAttribute("data-flip-id");
// 				id || el.setAttribute("data-flip-id", (id = "" + _id++));
// 				lookup[id] = before[i];
// 				fade && (fade[i] = before[i].o);
// 				(before[i].d === "none" || !before[i].p) && entering.push(el);
// 				if (props) {
// 					let getProp = gsap.getProperty(el, null, "native"),
// 						obj = before[i].props = {};
// 					i = props.length;
// 					while (i--) {
// 						obj[props[i]] = getProp(props[i]);
// 					}
// 				}
// 				el._flip && el._flip.progress(1);
// 				el._flip = tl;
// 			});
// 			onReady = () => {
// 				let swapIn = [],
// 					swapOut = [],
// 					remove = () => swapOut.forEach(el => el.parentNode && el.parentNode.removeChild(el)),
// 					offsets = absolute && [],
// 					after, index, id, el, state, all, i, x, y, width, height, scaleX, scaleY, leaving;
// 				all = _find(context);
// 				for (i = 0; i < all.length; i++) {
// 					el = all[i];
// 					id = el.getAttribute("data-flip-id");
// 					state = lookup[id];
// 					if (!state) {
// 						entering.push(el);
// 					} else if (swap !== false && state.el !== el) { // swap!
// 						elements.push(el);
// 						before.push(state);
// 						swapIn.push(el);
// 						swapOut.push(state.el);
// 						el._flip = tl;
// 						if (fade) {
// 							fade.push(0);
// 							state.el.style.opacity = "0";
// 						}
// 					}
// 				}
// 				swapOut.length || (fade = false);
// 				after = elements.map(_getDimensions);
// 				for (p in vars) {
// 					_reserved[p] || (copy[p] = vars[p]);
// 				}
// 				props && props.forEach(p => copy[p] = i => before[i].props[p]);
// 				_pluckTransitioning(elements, entering, before, after, onEnter, tl);
// 				if (onLeave) {
// 					leaving = [];
// 					i = elements.length;
// 					while (i--) {
// 						(after[i].d === "none" || !after[i].p) && leaving.push(elements[i]);
// 					}
// 					_pluckTransitioning(elements, leaving, before, after, onLeave, tl, true);
// 				}
// 				if (scale) {
// 					copy.x = x = i => after[i].x + (before[i].l - after[i].l) + ((before[i].bw / after[i].bw) * after[i].sx - after[i].sx) * after[i].origin[0];
// 					copy.y = y = i => after[i].y + (before[i].t - after[i].t) + ((before[i].bh / after[i].bh) * after[i].sy - after[i].sy) * after[i].origin[1];
// 					copy.scaleX = scaleX = i => after[i].sx * (before[i].bw / after[i].bw);
// 					copy.scaleY = scaleY = i => after[i].sy * (before[i].bh / after[i].bh);
// 				} else {
// 					absolute && (offsets = _makeAbsolute(elements, after, []));
// 					copy.x = x = i => after[i].x + (before[i].l - after[i].l) + (absolute ? offsets[i].x : 0);
// 					copy.y = y = i => after[i].y + (before[i].t - after[i].t) + (absolute ? offsets[i].y : 0);
// 					copy.width = width = i => before[i].w;
// 					copy.height = height = i => before[i].h;
// 				}
// 				fade ? (copy.opacity = i => fade[i]) : remove();
// 				copy.onComplete = () => elements.forEach((el, i) => {el._gsap.uncache = 1; el.style.cssText = after[i].css;}) || !fade || remove();
// 				swapOut.forEach((el, i) => {
// 					index = elements.indexOf(el);
// 					after[index] = before[index];
// 					before[index] = after[elements.indexOf(swapIn[i])];
// 					let v = {x: x(index), y: y(index)};
// 					if (scale) {
// 						v.scaleX = scaleX(index);
// 						v.scaleY = scaleY(index);
// 					} else {
// 						v.width = width(index);
// 						v.height = height(index);
// 					}
// 					gsap.set(el, v);
// 					before[index] = after[index];
// 				});
// 				onInit && onInit(tl, before, after);
// 				return (elements.length ? tl.from(elements, copy, 0) : tl).play();
// 			};
// 			changeResult = change(onReady);
// 			changeResult && changeResult instanceof gsap.core.Animation && tl.add(changeResult, 0);
// 			return vars.wait ? tl.pause() : onReady();
// 		}
//
// 		// add flip() to timelines? Potential future feature:
// 		// gsap.core.Timeline.prototype.flip = function(vars, position) {
// 		// 	let temp = gsap.to({}, {duration: vars.duration, delay: vars.delay, onStart: () => {
// 		// 			temp.parent.add(gsap.flip(vars), temp._start - temp._delay);
// 		// 			temp.kill();
// 		// 		}
// 		// 	});
// 		// 	return this.add(temp, position);
// 		// };
//
// 	}
// };

typeof(window) !== "undefined" && window.gsap && window.gsap.registerPlugin(Flip);

export { Flip as default };