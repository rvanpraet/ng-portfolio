/*!
 * EasePack 3.6.0
 * https://greensock.com
 *
 * @license Copyright 2008-2020, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */
export var Flip = {
  name: "flip",
  register: function register(gsap) {
    var _id = 1,
        _toArray = gsap.utils.toArray,
        _find = function _find(context) {
      return _toArray(_toArray(context || document.body)[0].querySelectorAll("[data-flip-id]"));
    },
        _reserved = {
      change: 1,
      targets: 1,
      onComplete: 1,
      onUpdate: 1,
      onStart: 1,
      delay: 1,
      scale: 1,
      context: 1,
      swap: 1,
      wait: 1,
      onInit: 1,
      absolute: 1,
      props: 1,
      onEnter: 1,
      onLeave: 1
    },
        _makeAbsolute = function _makeAbsolute(elements, state, result) {
      for (var i = 0; i < elements.length; i++) {
        var el = elements[i],
            s = state[i],
            b = void 0,
            o = void 0;
        el.parentNode || s.p && s.p.appendChild(el);
        gsap.getProperty(el, "display") === "none" && (el.style.display = s.d);
        el.style.position = "absolute";
        el.style.width = s.w + "px";
        el.style.height = s.h + "px";
        el.style.top = el.style.left = "0px";
        b = el.getBoundingClientRect();
        o = {
          x: s.l - b.left,
          y: s.t - b.top
        };
        gsap.set(el, {
          x: "+=" + o.x,
          y: "+=" + o.y
        });
        result && (result[i] = o);
      }

      return result;
    },
        _getDimensions = function _getDimensions(el) {
      var b = el.getBoundingClientRect(),
          getProp = gsap.getProperty(el);
      return {
        el: el,
        d: getProp("display"),
        p: el.parentNode,
        sx: getProp("scaleX"),
        sy: getProp("scaleY"),
        x: getProp("x"),
        y: getProp("y"),
        l: b.left,
        t: b.top,
        w: parseFloat(getProp("width", "px")),
        h: parseFloat(getProp("height", "px")),
        bw: b.width,
        bh: b.height,
        css: el.style.cssText,
        o: getProp("opacity"),
        origin: getComputedStyle(el).transformOrigin.split(" ").map(parseFloat)
      };
    },
        _pluckTransitioning = function _pluckTransitioning(elements, transitioning, before, after, callback, tl, useBefore) {
      if (transitioning.length) {
        var state = useBefore ? before : after,
            recordedStates = [],
            i,
            index,
            el;

        for (i = 0; i < transitioning.length; i++) {
          el = transitioning[i];
          index = elements.indexOf(el);
          useBefore || before[index].d === "none" && (el.style.display = after[index].d);

          if (~index) {
            recordedStates.push(state[index]);
            elements.splice(index, 1);
            before.splice(index, 1);
            after.splice(index, 1);
          } else {
            recordedStates.push(_getDimensions(transitioning[i]));
          }
        }

        callback && tl.add(callback(transitioning, function () {
          return _makeAbsolute(transitioning, recordedStates) || transitioning;
        }), 0);
      }
    };

    gsap.flip = function (vars) {
      (typeof vars !== "object" || vars.push) && (vars = {
        targets: vars
      });
      var _vars = vars,
          onComplete = _vars.onComplete,
          delay = _vars.delay,
          scale = _vars.scale,
          targets = _vars.targets,
          change = _vars.change,
          onUpdate = _vars.onUpdate,
          onStart = _vars.onStart,
          context = _vars.context,
          swap = _vars.swap,
          onInit = _vars.onInit,
          absolute = _vars.absolute,
          props = _vars.props,
          onEnter = _vars.onEnter,
          onLeave = _vars.onLeave,
          elements = targets ? _toArray(targets) : _find(context),
          tl = gsap.timeline({
        delay: delay,
        onStart: onStart,
        onUpdate: onUpdate,
        onComplete: onComplete
      }),
          fade = swap === "fade" && [],
          lookup = {},
          before = elements.map(_getDimensions),
          copy = {},
          entering = [],
          p,
          onReady,
          changeResult;
      props && (props = props.split(" ").join("").split(","));
      elements.forEach(function (el, i) {
        var id = el.getAttribute("data-flip-id");
        id || el.setAttribute("data-flip-id", id = "" + _id++);
        lookup[id] = before[i];
        fade && (fade[i] = before[i].o);
        (before[i].d === "none" || !before[i].p) && entering.push(el);

        if (props) {
          var getProp = gsap.getProperty(el, null, "native"),
              obj = before[i].props = {};
          i = props.length;

          while (i--) {
            obj[props[i]] = getProp(props[i]);
          }
        }

        el._flip && el._flip.progress(1);
        el._flip = tl;
      });

      onReady = function onReady() {
        var swapIn = [],
            swapOut = [],
            remove = function remove() {
          return swapOut.forEach(function (el) {
            return el.parentNode && el.parentNode.removeChild(el);
          });
        },
            offsets = absolute && [],
            after,
            index,
            id,
            el,
            state,
            all,
            i,
            x,
            y,
            width,
            height,
            scaleX,
            scaleY,
            leaving;

        all = _find(context);

        for (i = 0; i < all.length; i++) {
          el = all[i];
          id = el.getAttribute("data-flip-id");
          state = lookup[id];

          if (!state) {
            entering.push(el);
          } else if (swap !== false && state.el !== el) {
            // swap!
            elements.push(el);
            before.push(state);
            swapIn.push(el);
            swapOut.push(state.el);
            el._flip = tl;

            if (fade) {
              fade.push(0);
              state.el.style.opacity = "0";
            }
          }
        }

        swapOut.length || (fade = false);
        after = elements.map(_getDimensions);

        for (p in vars) {
          _reserved[p] || (copy[p] = vars[p]);
        }

        props && props.forEach(function (p) {
          return copy[p] = function (i) {
            return before[i].props[p];
          };
        });

        _pluckTransitioning(elements, entering, before, after, onEnter, tl);

        if (onLeave) {
          leaving = [];
          i = elements.length;

          while (i--) {
            (after[i].d === "none" || !after[i].p) && leaving.push(elements[i]);
          }

          _pluckTransitioning(elements, leaving, before, after, onLeave, tl, true);
        }

        if (scale) {
          copy.x = x = function x(i) {
            return after[i].x + (before[i].l - after[i].l) + (before[i].bw / after[i].bw * after[i].sx - after[i].sx) * after[i].origin[0];
          };

          copy.y = y = function y(i) {
            return after[i].y + (before[i].t - after[i].t) + (before[i].bh / after[i].bh * after[i].sy - after[i].sy) * after[i].origin[1];
          };

          copy.scaleX = scaleX = function scaleX(i) {
            return after[i].sx * (before[i].bw / after[i].bw);
          };

          copy.scaleY = scaleY = function scaleY(i) {
            return after[i].sy * (before[i].bh / after[i].bh);
          };
        } else {
          absolute && (offsets = _makeAbsolute(elements, after, []));

          copy.x = x = function x(i) {
            return after[i].x + (before[i].l - after[i].l) + (absolute ? offsets[i].x : 0);
          };

          copy.y = y = function y(i) {
            return after[i].y + (before[i].t - after[i].t) + (absolute ? offsets[i].y : 0);
          };

          copy.width = width = function width(i) {
            return before[i].w;
          };

          copy.height = height = function height(i) {
            return before[i].h;
          };
        }

        fade ? copy.opacity = function (i) {
          return fade[i];
        } : remove();

        copy.onComplete = function () {
          return elements.forEach(function (el, i) {
            el._gsap.uncache = 1;
            el.style.cssText = after[i].css;
          }) || !fade || remove();
        };

        swapOut.forEach(function (el, i) {
          index = elements.indexOf(el);
          after[index] = before[index];
          before[index] = after[elements.indexOf(swapIn[i])];
          var v = {
            x: x(index),
            y: y(index)
          };

          if (scale) {
            v.scaleX = scaleX(index);
            v.scaleY = scaleY(index);
          } else {
            v.width = width(index);
            v.height = height(index);
          }

          gsap.set(el, v);
          before[index] = after[index];
        });
        onInit && onInit(tl, before, after);
        return (elements.length ? tl.from(elements, copy, 0) : tl).play();
      };

      changeResult = change(onReady);
      changeResult && changeResult instanceof gsap.core.Animation && tl.add(changeResult, 0);
      return vars.wait ? tl.pause() : onReady();
    }; // add flip() to timelines? Potential future feature
    // gsap.core.Timeline.prototype.flip = function(vars, position) {
    // 	let temp = gsap.to({}, {duration: vars.duration, delay: vars.delay, onStart: () => {
    // 			temp.parent.add(gsap.flip(vars), temp._start - temp._delay);
    // 			temp.kill();
    // 		}
    // 	});
    // 	return this.add(temp, position);
    // };

  }
};
typeof window !== "undefined" && window.gsap && window.gsap.registerPlugin(Flip);
export { Flip as default };