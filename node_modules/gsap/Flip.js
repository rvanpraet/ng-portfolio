/*!
 * EasePack 3.6.0
 * https://greensock.com
 *
 * @license Copyright 2008-2020, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */
var _id = 1,
    _toArray,
    gsap,
    _calcGrowthDirection,
    _find = function _find(context) {
  return _toArray(_toArray(context || document.body)[0].querySelectorAll("[data-flip-id]"));
},
    _reserved = {
  change: 1,
  targets: 1,
  onComplete: 1,
  onUpdate: 1,
  onStart: 1,
  delay: 1,
  scale: 1,
  context: 1,
  swap: 1,
  wait: 1,
  onInit: 1,
  absolute: 1,
  props: 1,
  onEnter: 1,
  onLeave: 1,
  custom: 1,
  paused: 1,
  nested: 1
},
    _copy = function _copy(obj) {
  var result = {},
      p;

  for (p in obj) {
    _reserved[p] || (result[p] = obj[p]);
  }

  return result;
},
    _makeAbsolute = function _makeAbsolute(elements, state, result) {
  for (var i = 0; i < elements.length; i++) {
    var el = elements[i],
        s = state[i],
        b = void 0,
        o = void 0,
        style = el.style;
    el.parentNode || s.p && s.p.appendChild(el);
    gsap.getProperty(el, "display") === "none" && (style.display = s.d);
    style.position = "absolute";
    style.width = s.w + "px";
    style.height = s.h + "px";
    style.top || (style.top = "0px");
    style.left || (style.left = "0px");
    b = el.getBoundingClientRect();
    o = {
      x: s.l - b.left,
      y: s.t - b.top
    };
    gsap.set(el, {
      x: "+=" + o.x,
      y: "+=" + o.y
    });
    result && (result[i] = o);
  }

  return result;
},
    _getDimensions = function _getDimensions(el) {
  var b = el.getBoundingClientRect(),
      getProp = gsap.getProperty(el);
  return {
    el: el,
    d: getProp("display"),
    p: el.parentNode,
    sx: getProp("scaleX"),
    sy: getProp("scaleY"),
    x: getProp("x"),
    y: getProp("y"),
    l: b.left,
    t: b.top,
    w: parseFloat(getProp("width", "px")),
    h: parseFloat(getProp("height", "px")),
    bw: b.width,
    bh: b.height,
    css: el.style.cssText,
    o: getProp("opacity"),
    rx: 0,
    ry: 0,
    origin: getComputedStyle(el).transformOrigin.split(" ").map(parseFloat)
  };
},
    _populateGrowthRatios = function _populateGrowthRatios(measurements) {
  var w = measurements.w,
      h = measurements.h,
      el = measurements.el,
      l = measurements.l,
      t = measurements.t,
      bw = measurements.bw,
      bh = measurements.bh,
      style = el.style,
      startWidth = style.width,
      startHeight = style.height,
      b2;
  style.width = w + 100 + "px";
  style.height = h + 100 + "px";
  b2 = el.getBoundingClientRect();
  measurements.rx = Math.abs((b2.left - l) / (b2.width - bw));
  measurements.ry = Math.abs((b2.top - t) / (b2.height - bh));
  startWidth ? style.width = startWidth : style.removeProperty("width");
  startHeight ? style.height = startHeight : style.removeProperty("height");
},
    _getNestedOffsets = function _getNestedOffsets(el, property, flipTimeline) {
  var value = 0,
      lookup = flipTimeline._flipProps;

  while (el) {
    if (el._flip === flipTimeline) {
      value += lookup[property](el._flipI) - gsap.getProperty(el, property);
    }

    el = el.parentNode;
  }

  return value;
},
    _getX = function _getX(b, a, scale, offset, nested) {
  return a.x + (b.l - a.l) + (scale ? (b.bw / a.bw * a.sx - a.sx) * a.origin[0] : (b.bw - a.bw) * a.rx) + offset - (nested ? _getNestedOffsets(a.p, "x", nested) : 0);
},
    _getY = function _getY(b, a, scale, offset, nested) {
  return a.y + (b.t - a.t) + (scale ? (b.bh / a.bh * a.sy - a.sy) * a.origin[1] : (b.bh - a.bh) * a.ry) + offset - (nested ? _getNestedOffsets(a.p, "y", nested) : 0);
},
    _getScaleX = function _getScaleX(b, a) {
  return a.sx * (b.bw / a.bw);
},
    _getScaleY = function _getScaleY(b, a) {
  return a.sy * (b.bh / a.bh);
},
    // takes an Array of elements that are either transitioning out or in (onEnter/onLeave), removes them from the "elements" Array (and corresponding before/after), finds any that were set to display: none and sets them to what they are in the after state, and triggers a callback (if one is provided), passing the transitioning Array as well as a special function that the user can optionally call to make those elements position: absolute while keeping their viewport positions.
_pluckTransitioning = function _pluckTransitioning(elements, transitioning, before, after, callback, tl, useBefore) {
  if (transitioning.length) {
    var state = useBefore ? before : after,
        recordedStates = [],
        i,
        index,
        el;

    for (i = 0; i < transitioning.length; i++) {
      el = transitioning[i];
      index = elements.indexOf(el);
      useBefore || before[index].d === "none" && (el.style.display = after[index].d);

      if (~index) {
        recordedStates.push(state[index]);
        elements.splice(index, 1);
        before.splice(index, 1);
        after.splice(index, 1);
      } else {
        recordedStates.push(_getDimensions(transitioning[i]));
      }
    }

    callback && tl.add(callback(transitioning, function () {
      return _makeAbsolute(transitioning, recordedStates) || transitioning;
    }), 0);
  }
};

export var Flip = /*#__PURE__*/function () {
  function Flip(vars) {
    var onComplete = vars.onComplete,
        delay = vars.delay,
        scale = vars.scale,
        targets = vars.targets,
        change = vars.change,
        onUpdate = vars.onUpdate,
        onStart = vars.onStart,
        context = vars.context,
        swap = vars.swap,
        onInit = vars.onInit,
        absolute = vars.absolute,
        props = vars.props,
        onEnter = vars.onEnter,
        onLeave = vars.onLeave,
        custom = vars.custom,
        paused = vars.paused,
        wait = vars.wait,
        nested = vars.nested,
        self = this,
        elements = self.targets = targets ? _toArray(targets) : _find(context),
        tl = self.animation = gsap.timeline({
      delay: delay,
      onStart: onStart,
      onUpdate: onUpdate,
      paused: paused
    }),
        fade = swap === "fade" && [],
        lookup = {},
        copy = {},
        entering = [],
        p,
        changeResult,
        before;
    _calcGrowthDirection = 0;
    before = elements.map(_getDimensions);
    props && (props = props.split(" ").join("").split(","));
    self.measured = false;
    self.vars = vars;
    wait && tl.pause();
    elements.forEach(function (el, i) {
      var id = el.getAttribute("data-flip-id");
      id || el.setAttribute("data-flip-id", id = "" + _id++);
      lookup[id] = before[i];
      fade && (fade[i] = before[i].o);
      (before[i].d === "none" || !before[i].p) && entering.push(el);

      if (props) {
        var getProp = gsap.getProperty(el, null, "native"),
            obj = before[i].props = {};
        i = props.length;

        while (i--) {
          obj[props[i]] = getProp(props[i]);
        }
      }

      el._flip && el._flip.progress(1);
      el._flip = tl;
    });

    self.getFrom = function (target, property) {
      return typeof copy[property] === "function" && copy[property](elements.indexOf(_toArray(target)[0]));
    };

    self.measure = function () {
      self.measured = true;

      var swapIn = [],
          swapOut = [],
          remove = function remove() {
        return swapOut.forEach(function (el) {
          return el.parentNode && el.parentNode.removeChild(el);
        });
      },
          offsets = absolute && [],
          remainingProps = copy,
          after,
          index,
          id,
          el,
          state,
          all,
          i,
          x,
          y,
          width,
          height,
          scaleX,
          scaleY,
          leaving,
          v;

      if (context || swap) {
        all = _find(context);

        for (i = 0; i < all.length; i++) {
          el = all[i];
          id = el.getAttribute("data-flip-id");
          state = lookup[id];

          if (!state) {
            entering.push(el);
          } else if (swap !== false && state.el !== el) {
            // swap!
            elements.push(el);
            before.push(state);
            swapIn.push(el);
            swapOut.push(state.el);
            el._flip = tl;

            if (fade) {
              fade.push(0);
              state.el.style.opacity = "0";
            }
          }
        }
      }

      swapOut.length || (fade = false);
      after = elements.map(_getDimensions);

      for (p in vars) {
        _reserved[p] || (copy[p] = vars[p]);
      }

      props && props.forEach(function (p) {
        return copy[p] = function (i) {
          return before[i].props[p];
        };
      });

      _pluckTransitioning(elements, entering, before, after, onEnter, tl);

      if (onLeave) {
        leaving = [];
        i = elements.length;

        while (i--) {
          (after[i].d === "none" || !after[i].p) && leaving.push(elements[i]);
        }

        _pluckTransitioning(elements, leaving, before, after, onLeave, tl, true);
      }

      if (scale) {
        copy.scaleX = scaleX = function scaleX(i) {
          return _getScaleX(before[i], after[i]);
        };

        copy.scaleY = scaleY = function scaleY(i) {
          return _getScaleY(before[i], after[i]);
        };
      } else {
        absolute && (offsets = _makeAbsolute(elements, after, []));
        scale || after.forEach(_populateGrowthRatios);

        copy.width = width = function width(i) {
          return before[i].w;
        };

        copy.height = height = function height(i) {
          return before[i].h;
        };
      }

      copy.x = x = function x(i) {
        return _getX(before[i], after[i], scale, absolute ? offsets[i].x : 0, nested && tl);
      };

      copy.y = y = function y(i) {
        return _getY(before[i], after[i], scale, absolute ? offsets[i].y : 0, nested && tl);
      };

      if (nested) {
        tl._flipProps = copy;
        elements.forEach(function (el, i) {
          return el._flipI = i;
        });
      }

      fade ? copy.opacity = function (i) {
        return fade[i];
      } : remove();
      tl.eventCallback("onComplete", function () {
        elements.forEach(function (el, i) {
          el._gsap.uncache = 1;
          el.style.cssText = after[i].css;
        }) || !fade || remove();
        onComplete && onComplete.apply(tl, vars.onCompleteParams || []);
      });
      swapOut.forEach(function (el, i) {
        index = elements.indexOf(el);
        after[index] = before[index];
        before[index] = after[elements.indexOf(swapIn[i])];
        var v = {
          x: x(index),
          y: y(index)
        };

        if (scale) {
          v.scaleX = scaleX(index);
          v.scaleY = scaleY(index);
        } else {
          v.width = width(index);
          v.height = height(index);
        }

        gsap.set(el, v);
        before[index] = after[index];
      });
      onInit && onInit(self);

      if (custom && elements.length) {
        // bust out the custom properties as their own tweens so they can use different eases, durations, etc.
        remainingProps = _copy(copy);

        for (p in custom) {
          v = _copy(custom[p]);
          v[p] = copy[p];
          tl.from(elements, v, 0);
          delete remainingProps[p];
        }
      }

      return elements.length ? tl.from(elements, remainingProps, 0) : tl;
    };

    changeResult = change(self);
    changeResult && changeResult instanceof gsap.core.Animation && tl.add(changeResult, 0);
    wait || self.measured || self.measure();
  }

  Flip.fit = function fit(fromEl, toEl, vars) {
    fromEl = _toArray(fromEl)[0];

    var v = vars ? _copy(vars) : {},
        before = _getDimensions(_toArray(toEl)[0]),
        after = _getDimensions(fromEl),
        _ref = vars || v,
        absolute = _ref.absolute,
        scale = _ref.scale,
        offsets = absolute && _makeAbsolute([fromEl], [after], [])[0];

    v.x = _getX(before, after, scale, offsets ? offsets.x : 0);
    v.y = _getY(before, after, scale, offsets ? offsets.y : 0);

    if (scale) {
      v.scaleX = _getScaleX(before, after);
      v.scaleY = _getScaleY(before, after);
    } else {
      v.width = before.w;
      v.height = before.h;
    }

    return v;
  };

  Flip.register = function register(core) {
    gsap = core;
    _toArray = gsap.utils.toArray;

    gsap.flip = function (vars) {
      return new Flip(vars);
    };
  };

  return Flip;
}(); // export const Flip = {
// 	name: "flip",
// 	register(gsap) {
// 		let _id = 1,
// 			_toArray = gsap.utils.toArray,
// 			_find = context => _toArray(_toArray(context || document.body)[0].querySelectorAll("[data-flip-id]")),
// 			_reserved = {change:1, targets:1, onComplete:1, onUpdate:1, onStart:1, delay:1, scale:1, context:1, swap:1, wait:1, onInit:1, absolute:1, props:1, onEnter:1, onLeave:1},
// 			_makeAbsolute = (elements, state, result) => {
// 				for (let i = 0; i < elements.length; i++) {
// 					let el = elements[i],
// 						s = state[i], b, o,
// 						style = el.style;
// 					el.parentNode || (s.p && s.p.appendChild(el))
// 					gsap.getProperty(el, "display") === "none" && (style.display = s.d);
// 					style.position = "absolute";
// 					style.width = s.w + "px";
// 					style.height = s.h + "px";
// 					style.top || (style.top = "0px");
// 					style.left || (style.left = "0px");
// 					b = el.getBoundingClientRect();
// 					o = {x: s.l - b.left, y: s.t - b.top};
// 					gsap.set(el, {x: "+=" + o.x, y: "+=" + o.y });
// 					result && (result[i] = o);
// 				}
// 				return result;
// 			},
// 			_getDimensions = el => {
// 				let b = el.getBoundingClientRect(),
// 					getProp = gsap.getProperty(el);
// 				return { el: el, d: getProp("display"), p: el.parentNode, sx: getProp("scaleX"), sy: getProp("scaleY"), x: getProp("x"), y: getProp("y"), l: b.left, t: b.top, w: parseFloat(getProp("width", "px")), h: parseFloat(getProp("height", "px")), bw: b.width, bh: b.height, css: el.style.cssText, o: getProp("opacity"), origin: getComputedStyle(el).transformOrigin.split(" ").map(parseFloat) };
// 			},
// 			_pluckTransitioning = (elements, transitioning, before, after, callback, tl, useBefore) => {
// 				if (transitioning.length) {
// 					let state = useBefore ? before : after,
// 						recordedStates = [],
// 						i, index, el;
// 					for (i = 0; i < transitioning.length; i++) {
// 						el = transitioning[i];
// 						index = elements.indexOf(el);
// 						useBefore || (before[index].d === "none" && (el.style.display = after[index].d));
// 						if (~index) {
// 							recordedStates.push(state[index]);
// 							elements.splice(index, 1);
// 							before.splice(index, 1);
// 							after.splice(index, 1);
// 						} else {
// 							recordedStates.push(_getDimensions(transitioning[i]));
// 						}
// 					}
// 					callback && tl.add(callback(transitioning, () => _makeAbsolute(transitioning, recordedStates) || transitioning), 0);
// 				}
// 			};
// 		gsap.flip = vars => {
// 			(typeof(vars) !== "object" || vars.push) && (vars = {targets: vars});
// 			let {onComplete, delay, scale, targets, change, onUpdate, onStart, context, swap, onInit, absolute, props, onEnter, onLeave} = vars,
// 				elements = targets ? _toArray(targets) : _find(context),
// 				tl = gsap.timeline({delay, onStart, onUpdate, onComplete}),
// 				fade = swap === "fade" && [],
// 				lookup = {},
// 				before = elements.map(_getDimensions),
// 				copy = {},
// 				entering = [],
// 				p, onReady, changeResult;
// 			props && (props = props.split(" ").join("").split(","));
// 			elements.forEach((el, i) => {
// 				let id = el.getAttribute("data-flip-id");
// 				id || el.setAttribute("data-flip-id", (id = "" + _id++));
// 				lookup[id] = before[i];
// 				fade && (fade[i] = before[i].o);
// 				(before[i].d === "none" || !before[i].p) && entering.push(el);
// 				if (props) {
// 					let getProp = gsap.getProperty(el, null, "native"),
// 						obj = before[i].props = {};
// 					i = props.length;
// 					while (i--) {
// 						obj[props[i]] = getProp(props[i]);
// 					}
// 				}
// 				el._flip && el._flip.progress(1);
// 				el._flip = tl;
// 			});
// 			onReady = () => {
// 				let swapIn = [],
// 					swapOut = [],
// 					remove = () => swapOut.forEach(el => el.parentNode && el.parentNode.removeChild(el)),
// 					offsets = absolute && [],
// 					after, index, id, el, state, all, i, x, y, width, height, scaleX, scaleY, leaving;
// 				all = _find(context);
// 				for (i = 0; i < all.length; i++) {
// 					el = all[i];
// 					id = el.getAttribute("data-flip-id");
// 					state = lookup[id];
// 					if (!state) {
// 						entering.push(el);
// 					} else if (swap !== false && state.el !== el) { // swap!
// 						elements.push(el);
// 						before.push(state);
// 						swapIn.push(el);
// 						swapOut.push(state.el);
// 						el._flip = tl;
// 						if (fade) {
// 							fade.push(0);
// 							state.el.style.opacity = "0";
// 						}
// 					}
// 				}
// 				swapOut.length || (fade = false);
// 				after = elements.map(_getDimensions);
// 				for (p in vars) {
// 					_reserved[p] || (copy[p] = vars[p]);
// 				}
// 				props && props.forEach(p => copy[p] = i => before[i].props[p]);
// 				_pluckTransitioning(elements, entering, before, after, onEnter, tl);
// 				if (onLeave) {
// 					leaving = [];
// 					i = elements.length;
// 					while (i--) {
// 						(after[i].d === "none" || !after[i].p) && leaving.push(elements[i]);
// 					}
// 					_pluckTransitioning(elements, leaving, before, after, onLeave, tl, true);
// 				}
// 				if (scale) {
// 					copy.x = x = i => after[i].x + (before[i].l - after[i].l) + ((before[i].bw / after[i].bw) * after[i].sx - after[i].sx) * after[i].origin[0];
// 					copy.y = y = i => after[i].y + (before[i].t - after[i].t) + ((before[i].bh / after[i].bh) * after[i].sy - after[i].sy) * after[i].origin[1];
// 					copy.scaleX = scaleX = i => after[i].sx * (before[i].bw / after[i].bw);
// 					copy.scaleY = scaleY = i => after[i].sy * (before[i].bh / after[i].bh);
// 				} else {
// 					absolute && (offsets = _makeAbsolute(elements, after, []));
// 					copy.x = x = i => after[i].x + (before[i].l - after[i].l) + (absolute ? offsets[i].x : 0);
// 					copy.y = y = i => after[i].y + (before[i].t - after[i].t) + (absolute ? offsets[i].y : 0);
// 					copy.width = width = i => before[i].w;
// 					copy.height = height = i => before[i].h;
// 				}
// 				fade ? (copy.opacity = i => fade[i]) : remove();
// 				copy.onComplete = () => elements.forEach((el, i) => {el._gsap.uncache = 1; el.style.cssText = after[i].css;}) || !fade || remove();
// 				swapOut.forEach((el, i) => {
// 					index = elements.indexOf(el);
// 					after[index] = before[index];
// 					before[index] = after[elements.indexOf(swapIn[i])];
// 					let v = {x: x(index), y: y(index)};
// 					if (scale) {
// 						v.scaleX = scaleX(index);
// 						v.scaleY = scaleY(index);
// 					} else {
// 						v.width = width(index);
// 						v.height = height(index);
// 					}
// 					gsap.set(el, v);
// 					before[index] = after[index];
// 				});
// 				onInit && onInit(tl, before, after);
// 				return (elements.length ? tl.from(elements, copy, 0) : tl).play();
// 			};
// 			changeResult = change(onReady);
// 			changeResult && changeResult instanceof gsap.core.Animation && tl.add(changeResult, 0);
// 			return vars.wait ? tl.pause() : onReady();
// 		}
//
// 		// add flip() to timelines? Potential future feature:
// 		// gsap.core.Timeline.prototype.flip = function(vars, position) {
// 		// 	let temp = gsap.to({}, {duration: vars.duration, delay: vars.delay, onStart: () => {
// 		// 			temp.parent.add(gsap.flip(vars), temp._start - temp._delay);
// 		// 			temp.kill();
// 		// 		}
// 		// 	});
// 		// 	return this.add(temp, position);
// 		// };
//
// 	}
// };

typeof window !== "undefined" && window.gsap && window.gsap.registerPlugin(Flip);
export { Flip as default };