(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.window = global.window || {}));
}(this, (function (exports) { 'use strict';

	/*!
	 * EasePack 3.6.0
	 * https://greensock.com
	 *
	 * @license Copyright 2008-2020, GreenSock. All rights reserved.
	 * Subject to the terms at https://greensock.com/standard-license or for
	 * Club GreenSock members, the agreement issued with that membership.
	 * @author: Jack Doyle, jack@greensock.com
	*/
	var _id = 1,
	    _toArray,
	    gsap,
	    _find = function _find(context) {
	  return _toArray(_toArray(context || document.body)[0].querySelectorAll("[data-flip-id]"));
	},
	    _reserved = {
	  change: 1,
	  targets: 1,
	  onComplete: 1,
	  onUpdate: 1,
	  onStart: 1,
	  delay: 1,
	  scale: 1,
	  context: 1,
	  swap: 1,
	  wait: 1,
	  onInit: 1,
	  absolute: 1,
	  props: 1,
	  onEnter: 1,
	  onLeave: 1,
	  custom: 1,
	  paused: 1,
	  nested: 1
	},
	    _copy = function _copy(obj) {
	  var result = {},
	      p;

	  for (p in obj) {
	    _reserved[p] || (result[p] = obj[p]);
	  }

	  return result;
	},
	    _makeAbsolute = function _makeAbsolute(elements, state, result) {
	  for (var i = 0; i < elements.length; i++) {
	    var el = elements[i],
	        s = state[i],
	        b = void 0,
	        o = void 0,
	        style = el.style;
	    el.parentNode || s.p && s.p.appendChild(el);
	    gsap.getProperty(el, "display") === "none" && (style.display = s.d);
	    style.position = "absolute";
	    style.width = s.w + "px";
	    style.height = s.h + "px";
	    style.top || (style.top = "0px");
	    style.left || (style.left = "0px");
	    b = el.getBoundingClientRect();
	    o = {
	      x: s.l - b.left,
	      y: s.t - b.top
	    };
	    gsap.set(el, {
	      x: "+=" + o.x,
	      y: "+=" + o.y
	    });
	    result && (result[i] = o);
	  }

	  return result;
	},
	    _getDimensions = function _getDimensions(el) {
	  var b = el.getBoundingClientRect(),
	      getProp = gsap.getProperty(el);
	  return {
	    el: el,
	    d: getProp("display"),
	    p: el.parentNode,
	    sx: getProp("scaleX"),
	    sy: getProp("scaleY"),
	    x: getProp("x"),
	    y: getProp("y"),
	    l: b.left,
	    t: b.top,
	    w: parseFloat(getProp("width", "px")),
	    h: parseFloat(getProp("height", "px")),
	    bw: b.width,
	    bh: b.height,
	    css: el.style.cssText,
	    o: getProp("opacity"),
	    rx: 0,
	    ry: 0,
	    origin: getComputedStyle(el).transformOrigin.split(" ").map(parseFloat)
	  };
	},
	    _populateGrowthRatios = function _populateGrowthRatios(measurements) {
	  var w = measurements.w,
	      h = measurements.h,
	      el = measurements.el,
	      l = measurements.l,
	      t = measurements.t,
	      bw = measurements.bw,
	      bh = measurements.bh,
	      style = el.style,
	      startWidth = style.width,
	      startHeight = style.height,
	      b2;
	  style.width = w + 100 + "px";
	  style.height = h + 100 + "px";
	  b2 = el.getBoundingClientRect();
	  measurements.rx = Math.abs((b2.left - l) / (b2.width - bw));
	  measurements.ry = Math.abs((b2.top - t) / (b2.height - bh));
	  startWidth ? style.width = startWidth : style.removeProperty("width");
	  startHeight ? style.height = startHeight : style.removeProperty("height");
	},
	    _getNestedOffsets = function _getNestedOffsets(el, property, flipTimeline) {
	  var value = 0,
	      lookup = flipTimeline._flipProps;

	  while (el) {
	    if (el._flip === flipTimeline) {
	      value += lookup[property](el._flipI) - gsap.getProperty(el, property);
	    }

	    el = el.parentNode;
	  }

	  return value;
	},
	    _getX = function _getX(b, a, scale, offset, nested) {
	  return a.x + (b.l - a.l) + (scale ? (b.bw / a.bw * a.sx - a.sx) * a.origin[0] : (b.bw - a.bw) * a.rx) + offset - (nested ? _getNestedOffsets(a.p, "x", nested) : 0);
	},
	    _getY = function _getY(b, a, scale, offset, nested) {
	  return a.y + (b.t - a.t) + (scale ? (b.bh / a.bh * a.sy - a.sy) * a.origin[1] : (b.bh - a.bh) * a.ry) + offset - (nested ? _getNestedOffsets(a.p, "y", nested) : 0);
	},
	    _getScaleX = function _getScaleX(b, a) {
	  return a.sx * (b.bw / a.bw);
	},
	    _getScaleY = function _getScaleY(b, a) {
	  return a.sy * (b.bh / a.bh);
	},
	    _pluckTransitioning = function _pluckTransitioning(elements, transitioning, before, after, callback, tl, useBefore) {
	  if (transitioning.length) {
	    var state = useBefore ? before : after,
	        recordedStates = [],
	        i,
	        index,
	        el;

	    for (i = 0; i < transitioning.length; i++) {
	      el = transitioning[i];
	      index = elements.indexOf(el);
	      useBefore || before[index].d === "none" && (el.style.display = after[index].d);

	      if (~index) {
	        recordedStates.push(state[index]);
	        elements.splice(index, 1);
	        before.splice(index, 1);
	        after.splice(index, 1);
	      } else {
	        recordedStates.push(_getDimensions(transitioning[i]));
	      }
	    }

	    callback && tl.add(callback(transitioning, function () {
	      return _makeAbsolute(transitioning, recordedStates) || transitioning;
	    }), 0);
	  }
	};

	var Flip = function () {
	  function Flip(vars) {
	    var onComplete = vars.onComplete,
	        delay = vars.delay,
	        scale = vars.scale,
	        targets = vars.targets,
	        change = vars.change,
	        onUpdate = vars.onUpdate,
	        onStart = vars.onStart,
	        context = vars.context,
	        swap = vars.swap,
	        onInit = vars.onInit,
	        absolute = vars.absolute,
	        props = vars.props,
	        onEnter = vars.onEnter,
	        onLeave = vars.onLeave,
	        custom = vars.custom,
	        paused = vars.paused,
	        wait = vars.wait,
	        nested = vars.nested,
	        self = this,
	        elements = self.targets = targets ? _toArray(targets) : _find(context),
	        tl = self.animation = gsap.timeline({
	      delay: delay,
	      onStart: onStart,
	      onUpdate: onUpdate,
	      paused: paused
	    }),
	        fade = swap === "fade" && [],
	        lookup = {},
	        copy = {},
	        entering = [],
	        p,
	        changeResult,
	        before;
	    before = elements.map(_getDimensions);
	    props && (props = props.split(" ").join("").split(","));
	    self.measured = false;
	    self.vars = vars;
	    wait && tl.pause();
	    elements.forEach(function (el, i) {
	      var id = el.getAttribute("data-flip-id");
	      id || el.setAttribute("data-flip-id", id = "" + _id++);
	      lookup[id] = before[i];
	      fade && (fade[i] = before[i].o);
	      (before[i].d === "none" || !before[i].p) && entering.push(el);

	      if (props) {
	        var getProp = gsap.getProperty(el, null, "native"),
	            obj = before[i].props = {};
	        i = props.length;

	        while (i--) {
	          obj[props[i]] = getProp(props[i]);
	        }
	      }

	      el._flip && el._flip.progress(1);
	      el._flip = tl;
	    });

	    self.getFrom = function (target, property) {
	      return typeof copy[property] === "function" && copy[property](elements.indexOf(_toArray(target)[0]));
	    };

	    self.measure = function () {
	      self.measured = true;

	      var swapIn = [],
	          swapOut = [],
	          remove = function remove() {
	        return swapOut.forEach(function (el) {
	          return el.parentNode && el.parentNode.removeChild(el);
	        });
	      },
	          offsets = absolute && [],
	          remainingProps = copy,
	          after,
	          index,
	          id,
	          el,
	          state,
	          all,
	          i,
	          x,
	          y,
	          width,
	          height,
	          scaleX,
	          scaleY,
	          leaving,
	          v;

	      if (context || swap) {
	        all = _find(context);

	        for (i = 0; i < all.length; i++) {
	          el = all[i];
	          id = el.getAttribute("data-flip-id");
	          state = lookup[id];

	          if (!state) {
	            entering.push(el);
	          } else if (swap !== false && state.el !== el) {
	            elements.push(el);
	            before.push(state);
	            swapIn.push(el);
	            swapOut.push(state.el);
	            el._flip = tl;

	            if (fade) {
	              fade.push(0);
	              state.el.style.opacity = "0";
	            }
	          }
	        }
	      }

	      swapOut.length || (fade = false);
	      after = elements.map(_getDimensions);

	      for (p in vars) {
	        _reserved[p] || (copy[p] = vars[p]);
	      }

	      props && props.forEach(function (p) {
	        return copy[p] = function (i) {
	          return before[i].props[p];
	        };
	      });

	      _pluckTransitioning(elements, entering, before, after, onEnter, tl);

	      if (onLeave) {
	        leaving = [];
	        i = elements.length;

	        while (i--) {
	          (after[i].d === "none" || !after[i].p) && leaving.push(elements[i]);
	        }

	        _pluckTransitioning(elements, leaving, before, after, onLeave, tl, true);
	      }

	      if (scale) {
	        copy.scaleX = scaleX = function scaleX(i) {
	          return _getScaleX(before[i], after[i]);
	        };

	        copy.scaleY = scaleY = function scaleY(i) {
	          return _getScaleY(before[i], after[i]);
	        };
	      } else {
	        absolute && (offsets = _makeAbsolute(elements, after, []));
	        scale || after.forEach(_populateGrowthRatios);

	        copy.width = width = function width(i) {
	          return before[i].w;
	        };

	        copy.height = height = function height(i) {
	          return before[i].h;
	        };
	      }

	      copy.x = x = function x(i) {
	        return _getX(before[i], after[i], scale, absolute ? offsets[i].x : 0, nested && tl);
	      };

	      copy.y = y = function y(i) {
	        return _getY(before[i], after[i], scale, absolute ? offsets[i].y : 0, nested && tl);
	      };

	      if (nested) {
	        tl._flipProps = copy;
	        elements.forEach(function (el, i) {
	          return el._flipI = i;
	        });
	      }

	      fade ? copy.opacity = function (i) {
	        return fade[i];
	      } : remove();
	      tl.eventCallback("onComplete", function () {
	        elements.forEach(function (el, i) {
	          el._gsap.uncache = 1;
	          el.style.cssText = after[i].css;
	        }) || !fade || remove();
	        onComplete && onComplete.apply(tl, vars.onCompleteParams || []);
	      });
	      swapOut.forEach(function (el, i) {
	        index = elements.indexOf(el);
	        after[index] = before[index];
	        before[index] = after[elements.indexOf(swapIn[i])];
	        var v = {
	          x: x(index),
	          y: y(index)
	        };

	        if (scale) {
	          v.scaleX = scaleX(index);
	          v.scaleY = scaleY(index);
	        } else {
	          v.width = width(index);
	          v.height = height(index);
	        }

	        gsap.set(el, v);
	        before[index] = after[index];
	      });
	      onInit && onInit(self);

	      if (custom && elements.length) {
	        remainingProps = _copy(copy);

	        for (p in custom) {
	          v = _copy(custom[p]);
	          v[p] = copy[p];
	          tl.from(elements, v, 0);
	          delete remainingProps[p];
	        }
	      }

	      return elements.length ? tl.from(elements, remainingProps, 0) : tl;
	    };

	    changeResult = change(self);
	    changeResult && changeResult instanceof gsap.core.Animation && tl.add(changeResult, 0);
	    wait || self.measured || self.measure();
	  }

	  Flip.fit = function fit(fromEl, toEl, vars) {
	    fromEl = _toArray(fromEl)[0];

	    var v = vars ? _copy(vars) : {},
	        before = _getDimensions(_toArray(toEl)[0]),
	        after = _getDimensions(fromEl),
	        _ref = vars || v,
	        absolute = _ref.absolute,
	        scale = _ref.scale,
	        offsets = absolute && _makeAbsolute([fromEl], [after], [])[0];

	    v.x = _getX(before, after, scale, offsets ? offsets.x : 0);
	    v.y = _getY(before, after, scale, offsets ? offsets.y : 0);

	    if (scale) {
	      v.scaleX = _getScaleX(before, after);
	      v.scaleY = _getScaleY(before, after);
	    } else {
	      v.width = before.w;
	      v.height = before.h;
	    }

	    return v;
	  };

	  Flip.register = function register(core) {
	    gsap = core;
	    _toArray = gsap.utils.toArray;

	    gsap.flip = function (vars) {
	      return new Flip(vars);
	    };
	  };

	  return Flip;
	}();
	typeof window !== "undefined" && window.gsap && window.gsap.registerPlugin(Flip);

	exports.Flip = Flip;
	exports.default = Flip;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
